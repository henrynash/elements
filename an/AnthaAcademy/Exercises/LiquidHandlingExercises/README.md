## Exercises: Writing protocols

### Pre-requisites
- Lesson 1 of the Antha Academy
- golang book chapters 5-9

## Making a new element
A new template antha element and corresponding execution bundle can be generated by running the ```antharun new element``` command.

The protocol name is case sensitive and the first letter must be upper case. 

To make an new element called SplitSample we'd run the following command:

```bash
antharun new element SplitSample
```

A folder will be created containing two output files:

The Antha element should look like this:

```go 
// Protocol SplitSample performs something.
//
// All of this text should be used to describe what this protocol does.  It
// should begin with a one sentence summary begining with "Protocol X...". If
// neccessary, a empty line with a detailed description can follow (like this
// description does).
//
// Spend some time thinking of a good protocol name as this is the name by
// which this protocol will be referred. It should convey the purpose and scope
// of the protocol to an outsider and should suggest an obvious
// parameterization. 
//
// Protocol names are also case-sensitive, so try to use a consistent casing
// scheme.
//
// Examples of bad names:
//   - MyProtocol
//   - GeneAssembly
//   - WildCAPSsmallANDLARGE
//
// Better names:
//   - Aliquot
//   - TypeIIsConstructAssembly
protocol SplitSample

// Place golang packages to import here
import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
)

// Parameters to this protocol
Parameters (
	A float64
	B float64
	Option bool
	String string
	StringArray []string
	VolumeA wunit.Volume
	VolumeB wunit.Volume
)

// Output data of this protocol
Data (
	Sum float64
)

// Physical inputs to this protocol
Inputs (
	ComponentA *wtype.LHComponent
	ComponentB *wtype.LHComponent
)

// Physical outputs to this protocol
Outputs (
	MixedComponent *wtype.LHComponent
)

// Conditions to run on startup
Setup {

}

// The core process for this protocol. These steps are executed for each input.
Steps {
	Sum = A + B
	sampleA := mixer.Sample(ComponentA, VolumeA)
	sampleB := mixer.Sample(ComponentB, VolumeB)
	MixedComponent = Mix(sampleA, sampleB)
}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}

```

The Bundle file should look like this:

```json
{
  "processes": {
    "Process1": {
      "component": "SplitSample"
    }
  },
  "connections": null,
  "parameters": {
    "Process1": {
      "A": 2.99,
      "B": -1,
      "ComponentA": "water",
      "ComponentB": "water",
      "Option": false,
      "String": "Example",
      "StringArray": [
        "A",
        "B",
        "C"
      ],
      "VolumeA": "1ul",
      "VolumeB": "2ul"
    }
  },
  "config": null
}
```

### Important!
To use anthabuild to compile the antha file the an file will need to be within the antha-lang/elements/an folder. 

Otherwise the anthabuild command should be appended with AN_DIRS=<targetdirectory>.

e.g. 
```sh
anthabuild AN_DIRS=$GOPATH/src/github.com/my-antha-elements
```

## Excercises

### 1. Using what you've learnt in Lesson 1, adapt the protocol to Split an input solution into two output solutions. 

Using the parameters below modify the Steps block so the protocol correctly samples the Input solution into two output solutions, SolutionA and SolutionB of Volumes VolumeA and VolumeB.

The Parameters should look like this:

```go
Parameters(
VolumeA Volume
VolumeB Volume
)
```

The inputs:

```go
Inputs{
InputSolution *wtype.LHComponent
}
```


The outputs: 

```go
Outputs{
SolutionA *wtype.LHComponent
SolutionB *wtype.LHComponent
}
```

### 2. Generate a protocol called CherryPick which will take in a slice of components as an input and output a single component.

Using the parameters below modify the Steps block so the protocol correctly selects an input solution from a slice of InputSolutions. i.e. if the components were ["water","dna","fluorescein"] and PositionInSlice was 0; the "water" component would be selected. 

Write the protocol so that if MixToNewLocation is set to true the component will be sampled and mixed to a new location. 

i.e. 
```go
if MixToNewLocation {

} else {

}
```

The Parameters should look like this:

```go
Parameters(
PositionInSlice int
MixToNewLocation bool
SolutionVolume Volume
)
```

The inputs:

```go
Inputs{
InputSolutions []*wtype.LHComponent
}
```


The outputs: 

```go
Outputs{
OutputSolution *wtype.LHComponent
}
```

### 3. Modify CherryPick into a protocol called CherryPickSlice to take in a slice of positions to CherryPick

The Parameters should look like this:

```go
Parameters(
PositionsInSlice []int
MixToNewLocation bool
SolutionVolume Volume
)
```

The inputs:

```go
Inputs{
InputSolutions []*wtype.LHComponent
}
```


The outputs: 

```go
Outputs{
OutputSolutions []*wtype.LHComponent
}
```

### 4. Make a new protocol based around the [Transfer](https://github.com/antha-lang/elements/blob/master/an/Liquid_handling/Transfer/Transfer.an) protocol which will take in a slice of solutions and transfer them to a specified plate

The Parameters should look like this:

```go
Parameters(
TransferVolume Volume
Replicates int
)
```

The inputs:

```go
Inputs{
InputSolutions []*wtype.LHComponent
OutPlate *wtype.LHPlate
}
```


The outputs: 

```go
Outputs{
OutPutSolutions []*wtype.LHComponent
OutputSolutionsMap map[string][]*wtype.LHComponent // as a potentially more convenient output we can also return a map of the solutions using the name of the component as a key
}
```

### 5. Make a new protocol called Dilute which will automatically dilute a sample to an intermediate dilution plate and then transfer the diluted Sample into the OutPlate if SampleVolume is below a minimal threshold.
Return a warning back to the user if a dilution has occurred. 

Do this by writing a new function in the protocol which will call the [SerialDilution](https://github.com/antha-lang/elements/blob/master/an/Liquid_handling/SerialDilution/SerialDilution.an) element if the TargetTransferVolume.SIValue() < MinimalTransferVolume.SIValue()

The Parameters should look like this:

```go
Parameters(
TargetTransferVolume Volume
MinimalTransferVolume Volume
DilutionFactor int
)
```

The inputs:

```go
Inputs{
TransferSample *wtype.LHComponent
Diluent *wtype.LHComponent
DilutionPlate *wtype.LHPlate
OutPlate *wtype.LHPlate
}
```


The data outputs:

```go
Data(
Warning error
Diluted bool
)
```

The outputs: 

```go
Outputs{
FinalSolution *wtype.LHComponent
IntermediateSolution *wtype.LHComponent
}
```


### 6. Make a new protocol called Aliquot_multi based around the [Aliquot](https://github.com/antha-lang/elements/blob/master/starter/Aliquot/Aliquot.an) protocol which will take in a slice of solutions and Aliquot them all

Do this by recursively using the Aliquot element from within the Aliquot_multi element in a similar way to the AutoPCR_demo element shown in Lesson0.

The Parameters should look like this:

```go
Parameters(
SolutionToVolumeMap map[string]Volume
SolutionToReplicatesMap map[string]int
)
```

The inputs:

```go
Inputs{
InputSolutions []*wtype.LHComponent
}
```


The outputs: 

```go
Outputs{
OutputSolutionsMap map[string][]*wtype.LHComponent // as a potentially more convenient output we can also return a map of the solutions using the name of the component as a key
}
```

## Next Steps


